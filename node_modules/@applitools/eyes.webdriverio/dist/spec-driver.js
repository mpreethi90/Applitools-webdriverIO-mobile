"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrapDriver = exports.build = exports.waitUntilDisplayed = exports.scrollIntoView = exports.type = exports.hover = exports.click = exports.takeScreenshot = exports.visit = exports.getUrl = exports.getTitle = exports.getDriverInfo = exports.getOrientation = exports.setWindowSize = exports.getWindowSize = exports.getElementRect = exports.findElements = exports.findElement = exports.childContext = exports.parentContext = exports.mainContext = exports.executeScript = exports.isEqualElements = exports.isStaleElementError = exports.extractSelector = exports.transformElement = exports.isSelector = exports.isElement = exports.isDriver = void 0;
const utils = require("@applitools/utils");
const legacy = require("./legacy");
const LEGACY_ELEMENT_ID = 'ELEMENT';
const ELEMENT_ID = 'element-6066-11e4-a52e-4f735466cecf';
function extractElementId(element) {
    if (utils.types.has(element, 'elementId'))
        return element.elementId;
    else if (utils.types.has(element, ELEMENT_ID))
        return element[ELEMENT_ID];
    else if (utils.types.has(element, LEGACY_ELEMENT_ID))
        return element[LEGACY_ELEMENT_ID];
}
function transformSelector(selector) {
    if (selector instanceof legacy.By) {
        return selector.toString();
    }
    else if (utils.types.has(selector, ['type', 'selector'])) {
        if (selector.type === 'css')
            return `css selector:${selector.selector}`;
        else if (selector.type === 'xpath')
            return `xpath:${selector.selector}`;
        else
            return `${selector.type}:${selector.selector}`;
    }
    return selector;
}
function isDriver(browser) {
    return Boolean(browser.getPrototype && browser.desiredCapabilities && browser.requestHandler);
}
exports.isDriver = isDriver;
function isElement(element) {
    if (!element)
        return false;
    return element.value
        ? Boolean(element.value[ELEMENT_ID] || element.value[LEGACY_ELEMENT_ID])
        : Boolean(element[ELEMENT_ID] || element[LEGACY_ELEMENT_ID]);
}
exports.isElement = isElement;
function isSelector(selector) {
    return (utils.types.isString(selector) || utils.types.has(selector, ['type', 'selector']) || selector instanceof legacy.By);
}
exports.isSelector = isSelector;
function transformElement(element) {
    const elementId = extractElementId(utils.types.has(element, 'value') ? element.value : element);
    return { [ELEMENT_ID]: elementId, [LEGACY_ELEMENT_ID]: elementId };
}
exports.transformElement = transformElement;
function extractSelector(element) {
    return utils.types.has(element, 'selector') ? element.selector : undefined;
}
exports.extractSelector = extractSelector;
function isStaleElementError(error, selector) {
    if (!error)
        return false;
    const errOrResult = error.originalError || error;
    return errOrResult instanceof Error
        ? errOrResult.seleniumStack && errOrResult.seleniumStack.type === 'StaleElementReference'
        : errOrResult.value && errOrResult.selector && errOrResult.selector === selector;
}
exports.isStaleElementError = isStaleElementError;
function isEqualElements(_browser, element1, element2) {
    if (!element1 || !element2)
        return false;
    const elementId1 = extractElementId(element1);
    const elementId2 = extractElementId(element2);
    return elementId1 === elementId2;
}
exports.isEqualElements = isEqualElements;
async function executeScript(browser, script, arg) {
    const { value } = await browser.execute(script, arg);
    return value;
}
exports.executeScript = executeScript;
async function mainContext(browser) {
    await browser.frame(null);
}
exports.mainContext = mainContext;
async function parentContext(browser) {
    await browser.frameParent();
}
exports.parentContext = parentContext;
async function childContext(browser, element) {
    await browser.frame(element);
}
exports.childContext = childContext;
async function findElement(browser, selector) {
    const { value } = await browser.element(transformSelector(selector));
    return value;
}
exports.findElement = findElement;
async function findElements(browser, selector) {
    const { value } = await browser.elements(transformSelector(selector));
    return value;
}
exports.findElements = findElements;
async function getElementRect(browser, element) {
    const { value } = await browser.elementIdRect(extractElementId(element));
    return value;
}
exports.getElementRect = getElementRect;
async function getWindowSize(browser) {
    const { value: size } = (await browser.windowHandleSize());
    return { width: size.width, height: size.height };
}
exports.getWindowSize = getWindowSize;
async function setWindowSize(browser, size) {
    await browser.windowHandlePosition({ x: 0, y: 0 });
    await browser.windowHandleSize(size);
}
exports.setWindowSize = setWindowSize;
async function getOrientation(browser) {
    const orientation = (await browser.getOrientation());
    return orientation.toLowerCase();
}
exports.getOrientation = getOrientation;
async function getDriverInfo(browser) {
    var _a, _b;
    return {
        sessionId: browser.requestHandler.sessionID || browser.sessionId,
        isMobile: browser.isMobile,
        isNative: browser.isMobile && !browser.desiredCapabilities.browserName,
        deviceName: browser.desiredCapabilities.deviceName,
        platformName: (browser.isIOS && 'iOS') ||
            (browser.isAndroid && 'Android') ||
            browser.desiredCapabilities.platformName ||
            browser.desiredCapabilities.platform,
        platformVersion: browser.desiredCapabilities.platformVersion,
        browserName: (_a = browser.desiredCapabilities.browserName) !== null && _a !== void 0 ? _a : browser.desiredCapabilities.name,
        browserVersion: (_b = browser.desiredCapabilities.browserVersion) !== null && _b !== void 0 ? _b : browser.desiredCapabilities.version,
    };
}
exports.getDriverInfo = getDriverInfo;
async function getTitle(browser) {
    return browser.getTitle();
}
exports.getTitle = getTitle;
async function getUrl(browser) {
    return browser.getUrl();
}
exports.getUrl = getUrl;
async function visit(browser, url) {
    await browser.url(url);
}
exports.visit = visit;
async function takeScreenshot(driver) {
    return driver.saveScreenshot();
}
exports.takeScreenshot = takeScreenshot;
async function click(browser, element) {
    if (isSelector(element))
        element = await findElement(browser, element);
    await browser.elementIdClick(extractElementId(element));
}
exports.click = click;
async function hover(browser, element, offset) {
    if (isSelector(element))
        element = await findElement(browser, element);
    await browser.moveTo(extractElementId(element), offset === null || offset === void 0 ? void 0 : offset.x, offset === null || offset === void 0 ? void 0 : offset.y);
}
exports.hover = hover;
async function type(browser, element, keys) {
    if (isSelector(element))
        browser.setValue(transformSelector(element), keys);
    else
        browser.elementIdValue(extractElementId(element), keys);
}
exports.type = type;
async function scrollIntoView(browser, element, align = false) {
    if (isSelector(element))
        element = await findElement(browser, element);
    await browser.execute('arguments[0].scrollIntoView(arguments[1])', element, align);
}
exports.scrollIntoView = scrollIntoView;
async function waitUntilDisplayed(browser, selector, timeout) {
    await browser.waitForVisible(selector, timeout);
}
exports.waitUntilDisplayed = waitUntilDisplayed;
const browserOptionsNames = {
    chrome: 'goog:chromeOptions',
    firefox: 'moz:firefoxOptions',
};
async function build(env) {
    const webdriverio = require('webdriverio');
    const chromedriver = require('chromedriver');
    const parseEnv = require('@applitools/test-utils/src/parse-env');
    const { browser = '', capabilities, url, attach, proxy, configurable = true, args = [], headless, logLevel = 'silent', } = parseEnv(Object.assign(Object.assign({}, env), { legacy: true }));
    const options = {
        desiredCapabilities: Object.assign({ browserName: browser }, capabilities),
        logLevel,
        protocol: url.protocol ? url.protocol.replace(/:$/, '') : undefined,
        host: url.hostname,
        port: url.port,
        path: url.pathname,
    };
    if (configurable) {
        if (browser === 'chrome' && attach) {
            await chromedriver.start(['--port=9515'], true);
            options.protocol = 'http';
            options.host = 'localhost';
            options.port = '9515';
            options.path = '/';
        }
        const browserOptionsName = browserOptionsNames[browser || options.desiredCapabilities.browserName];
        if (browserOptionsName) {
            const browserOptions = options.desiredCapabilities[browserOptionsName] || {};
            browserOptions.args = [...(browserOptions.args || []), ...args];
            if (headless)
                browserOptions.args.push('headless');
            if (attach) {
                browserOptions.debuggerAddress = attach === true ? 'localhost:9222' : attach;
            }
            options.desiredCapabilities[browserOptionsName] = browserOptions;
        }
    }
    if (proxy) {
        options.desiredCapabilities.proxy = {
            proxyType: 'manual',
            httpProxy: proxy.http || proxy.server,
            sslProxy: proxy.https || proxy.server,
            ftpProxy: proxy.ftp,
            noProxy: proxy.bypass.join(','),
        };
    }
    const driver = webdriverio.remote(options);
    await driver.init();
    return [driver, () => driver.end().then(() => chromedriver.stop())];
}
exports.build = build;
exports.wrapDriver = legacy.wrapDriver;
//# sourceMappingURL=spec-driver.js.map